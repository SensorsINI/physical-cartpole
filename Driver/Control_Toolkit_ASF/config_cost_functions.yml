cost_function_name_default: default
# Default value is used if controller does not specify a cost_function_specification (leave empty)
# Cost functions are grouped by environment name in a folder within Control_Toolkit_ASF.Cost_Functions
# Check config.yml to learn more on how cost_functions are selected

# IMPORTANT, set parameters that should be float explicitly float by using either . or scientific notation! Otherwise, they will throw TypeError exception in tensorflow compiled code.

CartPole:
  default:
    dd_weight: 500.0
    ep_weight: 2000.0
    ekp_weight: 8.0
    ekc_weight: 2.0
    cc_weight: 1.0
    ccrc_weight: 1.0
    R: 1.0                                # How much to punish Q, For MPPI YOU have to make sure that this is the same as in optimizer config, as it plays a special role in the optimization algorithm as well as is used in cost functions!
  quadratic_boundary_grad:
    dd_weight: 600.0
    ep_weight: 20000.0
    ekp_weight: 80.0
    cc_weight: 1.0
    ccrc_weight: 1.0
    R: 1.0                                # How much to punish Q, For MPPI YOU have to make sure that this is the same as in optimizer config, as it plays a special role in the optimization algorithm as well as is used in cost functions!
  quadratic_boundary_nonconvex:
    dd_weight: 600.0
    ep_weight: 20000.0
    cc_weight: 1.0
    ccrc_weight: 1.0
    R: 1.0                                # How much to punish Q, For MPPI YOU have to make sure that this is the same as in optimizer config, as it plays a special role in the optimization algorithm as well as is used in cost functions!
  quadratic_boundary:
    dd_weight: 600.0
    ep_weight: 20000.0
    cc_weight: 1.0
    ccrc_weight: 1.0
    R: 1.0                                # How much to punish Q, For MPPI YOU have to make sure that this is the same as in optimizer config, as it plays a special role in the optimization algorithm as well as is used in cost functions!
  cartpole_dancer_cost: # values must be explicitly float or scientific format if needed, since they are cast to int type if provided here as int, which might not work for some ops
    # the policy (dance step or move to control). It is trailed by an int to code the policy as an int for tensorflow XLA compiled code.
    # e.g. dance0 will create (in update_attributes call) policy='dance' and policy_number=0
    # this hack is to allow branching in XLA code that lacks string compare operator
    # see others\globals_and_utilities.py\update_attributes method
    policy:  dance0  # dance0 (follow csv file)   balance1 spin2 shimmy3 cartonly4 cartwheel5

    # tobi cannot get conditional branch to work for following option in cartpole_dancer_cost.py
#    distance_norm: 0 # 0=abs, 1=rmse, 2=mse are possible distance metrics
    stage_cost_factor: 1e0 # how much to weight up the state costs
    track_edge_barrier_cost: 1e9 # how much to penalize cart at edge of track
    track_length_fraction: 0.8 # fraction of half track length to allow free movement of cart before hitting barrier function

    # cost weightings for the different state components for following desired cart state trajectory
    cart_pos_weight: 2e6 # weight on cart pos error
    pole_angle_weight: 1e6 # weight on difference of angle
    cart_vel_weight: 3e2 # weight on difference of cart velocity
    pole_swing_weight: 4e+4 # cart angle derivative weight

    # following weight the control and its change
    control_cost_weight: 1e1 # cost of control
    control_cost_change_weight: 1e0 # cost of changing control

    # spin
    spin_dir:  1  # cw+1 ccw-1 1 or cw, -1 or ccw
    upright_pole_energy_multiple_to_count_spin_direction_cost: .25 # pole must have this excess total energy before we start counting spin direction energy
    spin_energy_weight: 5e+6 # cost factor only for spin behavior to weight the spin energy


    # balance
    balance_dir: up # 1 or up, -1 or down, multiplied by target_equilibrium

    # shimmy does a sinusoidal dance of cart around target position with period in seconds and amplitude in meters
    shimmy_freq_hz: 1.125   # for 160bpm song, 2.25 Hz is beat, 1.125 is half beat, 0.5625 is quarter beat
    shimmy_amp: .04 # in practice, 0.03 results in about .07m amplitude, not clear why
    shimmy_freq2_hz: 2.
    shimmy_amp2: .025
    shimmy_duration: 8. # for shimmy that lasts a finite time and ramps from freq to freq2 and amp to amp2
    shimmy_dir: up # up, down
#    shimmy_plot: 0 # to plot the shimmy function

    # cartonly only controls cart position, pole is ignored. Trajectory is triangular with amp and per
    cartonly_amp: 0.1 # amplitude in meters (half of peak to peak of triangle wave)
    cartonly_freq_hz: 1.125
    cartonly_duty_cycle: 0.5 # set to .5 for triangle, 0 or 1 for sawtooth

    # cartwheel
    cartwheel_cycles: +5 # positive cw, negative ccw
    cartwheel_balance_angle_limit_deg: 10.0
    cartwheel_balance_angled_limit_deg_per_sec: 30.0
    cartwheel_freefall_angle_limit_deg: 20.
    cartwheel_freefall_angled_limit_deg_per_sec: 30.
    cartwheel_freefall_to_after_angle_limit_deg: 60.
#    cartwheel_target_duration_s: 1.1

    dance_song_file: 'others/Media/Rolling_Stones_Satisfaction.mp3' # no spaces or special chars, no / . - etc....
    dance_csv_file: 'Control_Toolkit_ASF/Cost_Functions/CartPole/cartpole_dance-satisfaction.csv'
    dance_song_playback_rate: 1. # rate to match song speed compared to real time simulation rate, we should set to 1 for song to sound native but code must run fast enough then
